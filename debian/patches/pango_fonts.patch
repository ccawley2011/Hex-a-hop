# Copyright (C) 2007  Jens Seidel <jensseidel@users.sf.net>
# Licensed under the GPL, see /usr/share/common-licenses/GPL

Index: hex-a-hop.svn/gfx.cpp
===================================================================
--- hex-a-hop.svn.orig/gfx.cpp	2007-09-20 00:49:19.000000000 +0200
+++ hex-a-hop.svn/gfx.cpp	2007-09-20 00:49:22.000000000 +0200
@@ -19,6 +19,7 @@
 #include "i18n.h"
 
 #include "state.h"
+#include <cassert>
 
 #ifdef WIN32
 	#include <SDL_syswm.h>
@@ -30,6 +31,14 @@
 	#undef USE_BBTABLET
 #endif
 
+// If included multiple times:
+// BUG: multiple definition of `MATRIX_WHITE_BACK'
+// see http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=437517
+#include "SDL_Pango.h"
+
+#include <algorithm>
+#include <string>
+
 #ifndef DATA_DIR
 #define DATA_DIR "."
 #endif
@@ -110,6 +119,7 @@
 float styluspressure = 0;
 SDL_Surface * screen = 0;
 SDL_Surface * realScreen = 0;
+SDLPango_Context *context = 0;
 
 extern State* MakeWorld();
 
@@ -157,6 +167,89 @@
 }
 String base_path;
 
+/// determine length of longest line with current font (wrapping allowed if text_width != -1)
+int SDLPangoTextHeight(const std::string &text_utf8, int text_width)
+{
+	// SDLPango_SetMinimumSize limits indeed the maximal size! See
+	// http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=438691
+	SDLPango_SetMinimumSize(context, text_width, 0);
+	SDLPango_SetText(context, text_utf8.c_str(), -1);
+	return SDLPango_GetLayoutHeight(context);
+}
+
+/** \brief Determine length of longest line with current font
+ *
+ * Whether line breaks are allowed or not needs to be set before using
+ * SDLPango_SetMinimumSize!
+ */
+int SDLPangoTextWidth(const std::string &text_utf8)
+{
+	SDLPango_SetText(context, text_utf8.c_str(), -1);
+	return SDLPango_GetLayoutWidth(context);
+}
+
+/// Display the specified UTF-8 text left aligned at (x,y)
+void Print_Pango(int x, int y, const std::string &text_utf8)
+{
+	// Workaround for possible crash, see
+	// http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=439071
+	if (text_utf8.size() == 0 || text_utf8.size() == 1 && text_utf8[0]==127)
+		return;
+	assert(text_utf8.find("\n") == std::string::npos);
+	SDLPango_SetMinimumSize(context, SCREEN_W, 0);
+	SDLPango_SetText(context, text_utf8.c_str(), -1);
+	SDL_Surface *surface = SDLPango_CreateSurfaceDraw(context);
+	SDL_Rect dst = {x, y, 1, 1};
+	SDL_BlitSurface(surface, NULL, screen, &dst);
+	SDL_FreeSurface(surface);
+}
+
+/** \brief Display the specified UTF-8 text according to the alignment
+ *
+ *  If line breaks are already properly set (manually) the will be respected
+ *  and no new line breaks will be added. This assumes that th text is not too
+ *  wide.
+ *
+ *  \param x the displayed text is horizontally centered around x
+ *  \param y the displayed text starts at y
+ *  \param width background window size into which the text needs to fit
+ *  \param text_utf8 the text to be displayed, in UTF8 encoding
+ *  \param align=1: horizontally centered around (x,y)
+ * */
+void Print_Pango_Aligned(int x, int y, int width, const std::string &text_utf8, int align)
+{
+	// Workaround for possible crash, see
+	// http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=439071
+	if (text_utf8.size() == 0 || text_utf8.size() == 1 && text_utf8[0]==127)
+		return;
+	if (width<=0)
+		return;
+	SDLPango_SetMinimumSize(context, width, 0);
+	int real_width = SDLPangoTextWidth(text_utf8);
+	// Workaround for a crash in SDL Pango, see
+	// http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=439855
+	if (real_width>width)
+		SDLPango_SetMinimumSize(context, real_width, 0);
+
+  SDLPango_Alignment alignment;
+  if (align==0)
+    alignment = SDLPANGO_ALIGN_LEFT;
+  else if (align==2) {
+    alignment = SDLPANGO_ALIGN_RIGHT;
+    x -= width;
+  } else {
+    alignment = SDLPANGO_ALIGN_CENTER;
+    x -= width/2;
+  }
+	// SDLPango_SetText_GivenAlignment is not (yet?) part of the official Pango
+	// distribution, see http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=437865
+	SDLPango_SetText_GivenAlignment(context, text_utf8.c_str(), -1, alignment);
+	SDL_Surface *surface = SDLPango_CreateSurfaceDraw(context);
+	SDL_Rect dst = {x, y, 1, 1};
+	SDL_BlitSurface(surface, NULL, screen, &dst);
+	SDL_FreeSurface(surface);
+}
+
 int TickTimer()
 {
 	static int time = SDL_GetTicks();
@@ -204,6 +297,10 @@
 */
 
 	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_NOPARACHUTE);
+	SDLPango_Init();
+	context = SDLPango_CreateContext_GivenFontDesc("sans-serif bold 12");
+	SDLPango_SetDefaultColor(context, MATRIX_TRANSPARENT_BACK_WHITE_LETTER);
+	SDLPango_SetMinimumSize(context, SCREEN_W, 0);
 
 	SDL_Surface* icon = SDL_LoadBMP("graphics/icon.bmp");
 	if (icon)
@@ -378,7 +475,7 @@
 						if (!td.isValid())
 							 printf("No tablet/driver found\n");
 					#endif
-  				}
+				}
 				if (m->msg == WM_DROPFILES)
 				{
 					HDROP h = (HDROP)m->wParam;
@@ -476,6 +573,7 @@
 		}
 	}
 
+	SDLPango_FreeContext(context);
 	SDL_Quit();
 	return 0;
 }
Index: hex-a-hop.svn/hex_puzzzle.cpp
===================================================================
--- hex-a-hop.svn.orig/hex_puzzzle.cpp	2007-09-20 00:49:19.000000000 +0200
+++ hex-a-hop.svn/hex_puzzzle.cpp	2007-09-20 00:49:22.000000000 +0200
@@ -17,6 +17,11 @@
 */
 
 #include "i18n.h"
+#include <string>
+#include <iostream>
+#include <cctype> // TODO: remove it later
+#include <errno.h>
+#include <iconv.h>
 
 //////////////////////////////////////////////////////
 // Config
@@ -401,15 +406,37 @@
 	}
 }
 
+void ConvertToUTF8(const std::string &text_locally_encoded, char *text_utf8, size_t text_utf8_length)
+{
+	// Is this portable?
+	size_t text_length = text_locally_encoded.length()+1;
+	errno = 0;
+	static const char *locale_enc = gettext_init.GetEncoding();
+	iconv_t cd = iconv_open("UTF-8", locale_enc);
+	char *in_buf = const_cast<char *>(&text_locally_encoded[0]);
+	char *out_buf = &text_utf8[0];
+	iconv(cd, &in_buf, &text_length, &out_buf, &text_utf8_length);
+	iconv_close(cd);
+	if (errno != 0)
+		std::cerr << "An error occurred recoding " << text_locally_encoded << " to UTF8" << std::endl;
+}
+
+int SDLPangoTextWidth(const std::string &text_utf8);
+void Print_Pango(int x, int y, const std::string &text_utf8);
+void Print_Pango_Aligned(int x, int y, int width, const std::string &text_utf8, int align);
+
+/// Prints a left aligned string (a single line) beginning at (x,y)
+// TODO: Check that the maximal text width is already set
 void Print(int x, int y, const char * string, ...)
 {
 	va_list marker;
 	va_start( marker, string );     /* Initialize variable arguments. */
 
-	char tmp[1000];
+	char tmp[1000], tmp_utf8[5000]; // FIXME: Check this limit
 	vsprintf((char*)tmp, string, marker);
 
-	PrintRaw(x, y, tmp);
+	ConvertToUTF8(tmp, tmp_utf8, sizeof(tmp_utf8)/sizeof(char));
+	Print_Pango(x, y, tmp_utf8);
 
 	va_end( marker );              /* Reset variable arguments.      */
 }
@@ -422,29 +449,38 @@
 	return w;
 }
 
+/// Prints a string right aligned so that it ends at (x,y)
+// TODO: Check that the maximal text width is already set
 void PrintR(int x, int y, const char * string, ...)
 {
 	va_list marker;
 	va_start( marker, string );     /* Initialize variable arguments. */
 
-	char tmp[1000];
+	char tmp[1000], tmp_utf8[5000]; // FIXME: Check this limit
 	vsprintf((char*)tmp, string, marker);
 
-	PrintRaw(x-FontWidth(tmp), y, tmp);
+	ConvertToUTF8(tmp, tmp_utf8, sizeof(tmp_utf8)/sizeof(char));
+	Print_Pango(x-SDLPangoTextWidth(tmp_utf8), y, tmp_utf8);
 
 	va_end( marker );              /* Reset variable arguments.      */
 }
 
-void PrintC(bool split, int x, int y, const char * string, ...)
+/** \brief Prints a string horizontally centered around (x,y)
+ *
+ *  "  " in the string is interpreted as linebreak
+*/
+void Print_Aligned(bool split, int x, int y, int width, const char * string, int align)
 {
-	va_list marker;
-	va_start( marker, string );     /* Initialize variable arguments. */
+	char tmp_utf8[5000]; // FIXME: Check this limit
 
-	char tmp[1000];
-	vsprintf((char*)tmp, string, marker);
+	ConvertToUTF8(string, tmp_utf8, sizeof(tmp_utf8)/sizeof(char));
 
-	char* scan = tmp;
-	while (1)
+	std::string msg(tmp_utf8);
+	while (split && msg.find("  ") != std::string::npos)
+		msg.replace(msg.find("  "), 2, "\n");
+
+	Print_Pango_Aligned(x, y, width, msg, align);
+  /*
 	{
 		char * end = split ? strstr(scan,"  ") : 0;
 		if (!end)
@@ -460,10 +496,28 @@
 			y += FONT_SPACING;
 		}
 	}
+  */
+}
+
+void PrintC(bool split, int x, int y, const char * string, ...)
+{
+	va_list marker;
+	va_start( marker, string );     /* Initialize variable arguments. */
+
+	char tmp[1000]; // FIXME: Check this limit
+	vsprintf((char*)tmp, string, marker);
 
 	va_end( marker );              /* Reset variable arguments.      */
-}
 
+	static bool print = true; // avoid flickering!
+	if (print) {
+		std::cerr << "Warning: don't know window width for message:\n" << tmp << "\n";
+		for (unsigned int i=0; i<strlen(tmp); ++i)
+			if (!std::isspace(tmp[i]))
+				print = false;
+	}
+	Print_Aligned(split, x, y, 2*std::min(x, SCREEN_W-x), tmp, 1);
+}
 
 #include "savestate.h"
 #include "menus.h"
Index: hex-a-hop.svn/Makefile
===================================================================
--- hex-a-hop.svn.orig/Makefile	2007-09-20 00:49:19.000000000 +0200
+++ hex-a-hop.svn/Makefile	2007-09-20 00:49:22.000000000 +0200
@@ -19,7 +19,7 @@
 	$(GCC) $(CXXFLAGS) -D_VERSION=\"$(VERSION)\" -DDATA_DIR=\"$(DATA_DIR)\" `sdl-config --cflags`  -c -o $@ $<
 	
 $(NAME) : $(OBJS)
-		$(GCC) $(CXXFLAGS) $(OBJS)  `sdl-config --libs` -lm  \
+		$(GCC) $(CXXFLAGS) $(OBJS)  `sdl-config --libs` -lSDL_Pango -lm  \
 		-o $(NAME)
 
 clean :
Index: hex-a-hop.svn/menus.h
===================================================================
--- hex-a-hop.svn.orig/menus.h	2007-09-20 00:49:19.000000000 +0200
+++ hex-a-hop.svn/menus.h	2007-09-20 00:49:22.000000000 +0200
@@ -16,11 +16,14 @@
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
 
+#include <string>
 
 struct Menu;
 Menu* activeMenu = 0;
 Menu* deadMenu = 0;
 
+int SDLPangoTextHeight(const std::string &text_utf8, int width);
+
 static void HackKeyPress(int key, int mod)
 {
 	int k = keyState[key];
@@ -154,11 +157,22 @@
 {
 	static int flags;
 
+	SDL_Rect InnerTextWindowRect;
+	SDL_Rect OuterTextWindowRect;
 	const char * msg;
-	char title[50];
-	int numLines;
+	char title[50]; // FIXME
 	int state;
 
+	const SDL_Rect &GetInnerWindowRect() const
+	{
+		return InnerTextWindowRect;
+	}
+
+	const SDL_Rect &GetOuterWindowRect() const
+	{
+		return OuterTextWindowRect;
+	}
+
 	static bool FlagTile(int t, bool newStuff=true)
 	{
 		if (t==LIFT_UP) t=LIFT_DOWN;
@@ -176,7 +190,6 @@
 
 	void Init(const char * m)
 	{
-		numLines = 1;
 		state = 0; time = 0;
 		memset(title, 0, sizeof(title));
 		char * x = strstr(m, "|");
@@ -191,9 +204,19 @@
 			msg=x+1;
 		}
 
-		const char * s = m;
-		while ((s=strstr(s, "  ")))
-			s+=2, numLines++;
+		char msg_utf8[5000];
+		ConvertToUTF8(msg, msg_utf8, sizeof(msg_utf8)/sizeof(char));
+
+		std::string text(msg_utf8);
+		while (text.find("  ") != std::string::npos)
+			text.replace(text.find("  "), 2, "\n");
+
+		InnerTextWindowRect.w = SCREEN_W-TILE_W1*2; 
+		InnerTextWindowRect.h = SDLPangoTextHeight(text, InnerTextWindowRect.w - 2*FONT_SPACING);
+		InnerTextWindowRect.h += FONT_SPACING;
+		OuterTextWindowRect = InnerTextWindowRect;
+		OuterTextWindowRect.w += 4;
+		OuterTextWindowRect.h += FONT_SPACING+4;
 	}
 
 	virtual void Render()
@@ -205,17 +228,35 @@
 		Render(0, y);
 		
 		if (!state && time>0.2)
-			Print(SCREEN_W*3/4, SCREEN_H-FONT_SPACING, _("Press any key"));
+			PrintR(SCREEN_W-FONT_SPACING, SCREEN_H-FONT_SPACING, _("Press any key"));
 	}
 
 	void Render(int x, int y)
 	{
-		SDL_Rect r2 = {x+TILE_W1, y, SCREEN_W-TILE_W1*2, numLines*FONT_SPACING+FONT_SPACING};
-		SDL_Rect r = {r2.x-2, r2.y-2-FONT_SPACING, r2.w+4, r2.h+4+FONT_SPACING};
+		//if (y<0) {
+		//  std::cout << "Error in Render: " << x << " " << y << "\n"; // CHECKME
+		//  y = 0;
+		//}
+		InnerTextWindowRect.x = x+TILE_W1;
+		InnerTextWindowRect.y = y;
+		OuterTextWindowRect.x = InnerTextWindowRect.x-2;
+		OuterTextWindowRect.y = InnerTextWindowRect.y-2-FONT_SPACING;
+		// Height is reduced in SDL_FillRect!!? Why? ==> Use a copy:
+		SDL_Rect r2 = InnerTextWindowRect;
+		SDL_Rect r = OuterTextWindowRect;
 		SDL_FillRect(screen, &r, SDL_MapRGB(screen->format, 60,90,90));
 		SDL_FillRect(screen, &r2, SDL_MapRGB(screen->format, 20,50,50));
-		Print(r.x+FONT_SPACING/4, y-FONT_SPACING, title);
-		PrintC(true, x+SCREEN_W/2, y+FONT_SPACING/2, msg);
+		Print(OuterTextWindowRect.x+FONT_SPACING/4, y-FONT_SPACING, "%s", title);
+		/* TRANSLATORS: This specifies how the text in the help dialog should
+		   be aligned. Do *not* translate the text itself but use one of "left",
+       "center" or "right" (untranslated!). The default is "center". */
+		std::string alignment = _("text alignment");
+		if (alignment == "right")
+			Print_Aligned(true, InnerTextWindowRect.x + InnerTextWindowRect.w - FONT_SPACING, y+FONT_SPACING/2, InnerTextWindowRect.w - 2*FONT_SPACING, msg, 2);
+		else if (alignment == "left")
+			Print_Aligned(true, InnerTextWindowRect.x + FONT_SPACING, y+FONT_SPACING/2, InnerTextWindowRect.w - 2*FONT_SPACING, msg, 0);
+		else
+			Print_Aligned(true, x+SCREEN_W/2, y+FONT_SPACING/2, InnerTextWindowRect.w - 2*FONT_SPACING, msg, 1);
 	}
 
 	virtual void Mouse(int /*x*/, int /*y*/, int /*dx*/, int /*dy*/, int buttons_pressed, int /*buttons_released*/, int /*buttons*/) 
@@ -265,7 +306,8 @@
 		{
 			if (y < SCREEN_H/4-FONT_SPACING+2)
 				Move(-1);
-			else if (y > SCREEN_H/4+FONT_SPACING*numLines+FONT_SPACING)
+			else if (y > HintMessage::GetOuterWindowRect().y+
+					HintMessage::GetOuterWindowRect().h)
 				Move(1);
 			else
 				Cancel();
@@ -304,7 +346,8 @@
 		//if (!noMouse)
 		{
 			PrintC(false, SCREEN_W/2, y-FONT_SPACING*2, "^");
-			PrintC(false, SCREEN_W/2, y+FONT_SPACING*(numLines+1)+FONT_SPACING/2-2, "_");
+			PrintC(false, SCREEN_W/2, HintMessage::GetOuterWindowRect().y+
+					HintMessage::GetOuterWindowRect().h, "_");
 		}
 
 		HintMessage::Render(0,y);

Index: hex-a-hop.svn/hex_puzzzle.cpp
===================================================================
--- hex-a-hop.svn.orig/hex_puzzzle.cpp	2007-09-20 00:49:33.000000000 +0200
+++ hex-a-hop.svn/hex_puzzzle.cpp	2007-09-20 00:49:35.000000000 +0200
@@ -608,8 +608,8 @@
 	{
 		if (currentStage > 0 && numStages > 0)
 		{
-			memmove(&time[0], &time[currentStage], sizeof(time[0]) * numStages-currentStage);
-			memmove(&stage[0], &stage[currentStage], sizeof(stage[0]) * numStages-currentStage);
+			memmove(&time[0], &time[currentStage], sizeof(time[0]) * (numStages-currentStage));
+			memmove(&stage[0], &stage[currentStage], sizeof(stage[0]) * (numStages-currentStage));
 			numStages -= currentStage;
 			currentStage = 0;
 		}
@@ -1804,6 +1804,9 @@
 	char* ReadAll(FILE* f)
 	{
 		int size;
+    // FIXME: According to http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht20Ht/c_faq_de
+    // undefined for binary streams! (POSIX does not differ between ascii and binary, so
+    // we are on the save side in Linux)
 		fseek(f, 0, SEEK_END);
 		size = ftell(f);
 		fseek(f, 0, SEEK_SET);
@@ -1888,7 +1891,8 @@
 				PackFile1::Entry* e = levelFiles.Find(filename);
 				if (!e) return false;
 
-				strcpy(currentFile, filename);
+				if (currentFile != filename) // equal (overlapping) strings are forbidden
+					strcpy(currentFile, filename);
 				currentLevelInfo = GetLevelInfo(currentFile);
 				
 				loadPtr = (char*)e->Data();
Index: hex-a-hop.svn/packfile.h
===================================================================
--- hex-a-hop.svn.orig/packfile.h	2007-09-20 00:49:19.000000000 +0200
+++ hex-a-hop.svn/packfile.h	2007-09-20 00:49:35.000000000 +0200
@@ -29,9 +29,22 @@
 
 struct PackFile1
 {
+  /* Is it *NOT* save to interpret a byte stream as list of Entries!
+   * The alignment could increase the Entry size on some systems without attribute.
+   *
+   * It works on: i386, amd64, mips o32 ABI, powerPC
+   * Maybe it's also compiler dependent ...
+   * 
+   * See also http://c-faq.com/struct/padding.html,
+   * http://c-faq.com/strangeprob/ptralign.html and Debian bug #442854
+   * (Need to refer to a C FAQ in a (so called) C++ program, argh ...)
+   * */
 	class Entry {
 		int32_t len;
 	public:
+		// an array of size 1 (no char* pointer!) is saved after len,
+		// accessing name[0] should (but doesn't always) fit the first byte after len
+		// See e.g. http://c-faq.com/aryptr/index.html 
 		char name[1];
 
 		Entry* GetNext()
@@ -51,7 +64,13 @@
 		{
 			return len - strlen(name) - 1;
 		}
-	};
+	}
+#ifdef __GNUC__
+   __attribute__ ((__packed__));
+	 int static_assert1[sizeof(Entry)==5 ? 0 : -1];
+#else
+  int static_assert1[sizeof(Entry)<=8 ? 0 : -1];
+#endif
 
 	int numfiles;
 	Entry** e;
